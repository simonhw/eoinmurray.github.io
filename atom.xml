<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Eoin Murray]]></title>
  <link href="http://eoinmurray.github.io/atom.xml" rel="self"/>
  <link href="http://eoinmurray.github.io/"/>
  <updated>2013-05-16T19:52:36+01:00</updated>
  <id>http://eoinmurray.github.io/</id>
  <author>
    <name><![CDATA[Eoin Murray]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Rontgen.js]]></title>
    <link href="http://eoinmurray.github.io/blog/2013/05/15/rontgen-dot-js/"/>
    <updated>2013-05-15T11:30:00+01:00</updated>
    <id>http://eoinmurray.github.io/blog/2013/05/15/rontgen-dot-js</id>
    <content type="html"><![CDATA[<h3><a href="http://eoinmurray.github.io/rontgen">Check out the demo here</a>.</h3>

<p>I have been working on an online LaTex and markdown for the last few days. In the same vain as <a href="http://socrates.io">Socrates.io</a> and <a href="http://dillinger.io">Dilliner.io</a> but with a bit more performance on the latex side. Mathjax is library for rendering LaTex on the web, but it is pretty slow. Socrates solves the performance issue by debouncing the math render by half a second, but this means that you have a lot of math flicking on and off. In my opinion this defeats the purpose of the real time math.</p>

<p>Enter Rontgen.js, my solution to the above problem. Check it out <a href="http://eoinmurray.github.io/rontgen">here</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Lorentz.js]]></title>
    <link href="http://eoinmurray.github.io/blog/2013/05/15/simulations/"/>
    <updated>2013-05-15T00:00:00+01:00</updated>
    <id>http://eoinmurray.github.io/blog/2013/05/15/simulations</id>
    <content type="html"><![CDATA[<p><strong><a href="http://github.com/eoinmurray/lorentz">Lorentz.js</a> is a node.js module that watches for client side file changes and reloads the browser.</strong></p>

<pre><code>npm install lorentz
</code></pre>

<p>Server side.</p>

<pre><code>var lorentz = require('lorentz')
lorentz.liveReload(__dirname[, port]) // defaults to 8081
</code></pre>

<p>Client-side.</p>

<pre><code>&lt;script src="http://localhost:8081/lorentz.js"&gt;&lt;/script&gt;
</code></pre>

<p>Specify the files you want to watch in a .lorentzwatch file.</p>

<pre><code>public/
app.js
index.html
</code></pre>

<h3>Todo</h3>

<ol>
<li>Make such that a cli version of lorentz can be run from any dir, and will support any language set up then.</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fun with qubits.]]></title>
    <link href="http://eoinmurray.github.io/blog/2013/05/15/quantum-dots/"/>
    <updated>2013-05-15T00:00:00+01:00</updated>
    <id>http://eoinmurray.github.io/blog/2013/05/15/quantum-dots</id>
    <content type="html"><![CDATA[<p><strong>In my opinion, this is a bunch of stuff that anyone interested in quantum communication should know about how quibits behave.</strong></p>

<h2>Superposition.</h2>

<p>If you look at a cylindrical block from the bottom, you see a circle. If you look at it from the side you see a square.</p>

<p>Imagine a cylindrical block that is spinning around amazingly fast. When you look at it, it stops spinning and snaps into either a circle or a square.</p>

<p>This is similar to how a qubit will behave. Whereas a normal bit has a value of either one or zero. A qubit is both. A qubit has some amount of one and some amount of zero, however when you measure it the qubit will <em>always</em> snap into a one or zero.
These measurements are probabilistic and will not be the same each time.</p>

<p>We represent a qubit as:</p>

<p>$$\ \left|\psi\right\rangle = \alpha \left|0\right\rangle + \beta  \left|1\right\rangle$$.</p>

<p>When you make a measurement on $ \left|\psi\right\rangle $ it will have result 1 with probability $\alpha^2$ and results 0 with probability $\beta^2$.</p>

<h2>The quantum in qubit.</h2>

<p>By definition a quantum is an indivisible unit. It has no smaller components.</p>

<p>A photon is a quantum of light, it is the light particle. An important property of photons is that they cannot be split in two, this is very useful in quanutum communication.</p>

<p>In normal radio communication you can absorb 50% of the wave and the other 50% will move on unaffected. In single photon communication this is <strong>not so</strong>.</p>

<p>Say you have a series of bits encoded in a regulated beam of single photons, if part of this beam is destroyed or absorbed, pieces of information are lost. Thus you can tell when your message has been tampered checking if all of the qubits remain.</p>

<p><em>(A radio wave is just millions of photons, but many-many of them will be encoded with the same information.)</em></p>

<h2>The no cloning theorem.</h2>

<p>The no cloning theorem states that a general qubit <em>cannot</em> be copied. This is integral to the BB84 quantum encryption protocol, and most other quantum protocols (I will talk about BB84 in a later blog post).
Say Alice and Bob use qubits to communicate and Eve intercepts the stream. Eve cannot accurately resend the qubit that she intercepts. This will make more sense in the context of an algorithm in a later post.</p>

<p><strong>Here is a short(weak) proof of the no-cloning theorem.</strong></p>

<p>Suppose that $U$ is a unitary operator that can clone a qubit $\ \left|\psi\right\rangle$. Then $U$ can clone that states $\ \left|0\right\rangle$ and $\ \left|1\right\rangle$:</p>

<p>$$U\ \left|0\right\rangle = \left|00\right\rangle,  \tag{1}$$</p>

<p>$$U\ \left|1\right\rangle = \left|11\right\rangle,  \tag{2}$$</p>

<p>Next if we apply $U$ to a qubit $\ \left|\psi\right\rangle = \alpha \left|0\right\rangle + \beta  \left|1\right\rangle$, knowing that $U$ is unitary so that
$\ U\left|\psi\right\rangle = \alpha U\left|0\right\rangle + \beta U\left|1\right\rangle$. Plugging in eqns (1) and (2), we get</p>

<p>$$\ U\left|\psi\right\rangle = \alpha \left|00\right\rangle + \beta \left|11\right\rangle. \tag{3}$$</p>

<p>However if $U$ could clone $\ \left|\psi\right\rangle$, we would get</p>

<p>$$\ U\left|\psi\right\rangle = \left|\psi\right\rangle\left|\psi\right\rangle = \alpha^2 \left|00\right\rangle + \alpha \beta \left|01\right\rangle + \beta \alpha \left|10\right\rangle + \beta^2 \left|11\right\rangle. \tag{4}$$</p>

<p>We can see that clearly eqn 4 is not the same as eqn 3. This shows that when a <em>linear operator</em> operates on a quantum state, cloning the state is impossible.</p>
]]></content>
  </entry>
  
</feed>
